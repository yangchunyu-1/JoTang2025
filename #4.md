# #4-杨春宇
*****

### 1. 从c源码到可执行文件的完整流程

1. **预处理**
    使用预处理器工具（如cpp）将诸如a.c格式的c源码处理成a.i格式，同时去掉代码中的注释，主要工作有：
    - 展开头文件：将`#include <stdio.h>`等指令替换为头文件的实际内容
    - 替换宏定义：将代码中`#define`定义的宏展开替换为具体的值或代码片段
    - 处理条件编译：根据`#if`，`#ifdef`等指令，决定那些代码块需要保留到下一步
2. **编译**
    使用编译器工具，将预处理后的c源码（`a.i`）翻译成汇编代码文件（`a.s`），主要工作有：
    - 语法，词法，语义分析：检查代码是否符合c语言语法，同时检查表达式是否合法等（但逻辑bug不会报错）
    - 中间代码生成与优化
    - 代码生成：将优化后的中间代码转换为特定cpu架构（如x86,ARM）的汇编代码
3. **汇编**
    使用汇编器工具，将汇编代码文件转换为机器码目标文件（`.o`或`.obj`），主要工作有：
    - 汇编器将汇编指令翻译为二进制机器码，生成可重定位目标文件
4. **链接**
    使用链接器工具，将多个目标文件（`.o`）和库文件合并为单一可执行文件（`a.out`或`a.exe`），主要工作有：
    - 符号解析：解决函数和变量的引用，如`printf()`
    - 重定位：调整函数和变量的内存地址，使其在最终程序中正确关联
    - 合并代码段和数据段：将所有目标文件中的代码和数据整合到可执行文件
    - 处理动/静态库
*****

### 2. 编译型语言和解释型语言的对比

- **编译型语言**：源代码通过编译器一次性翻译成机器码，生成独立的可执行文件；执行速度快；跨平台性差；源代码保密性好；但编译-链接过程耗时
- **解释型语言**：源代码在运行时由解释器逐行读取、翻译并立即执行；执行速度慢；跨平台性好；源代码保密性差；在开发调试中可快速迭代，即修改代码后可以立即运行测试，无需等待漫长的编译过程
*****
  
### 3. 一些思考题

1. **为什么 C 程序通常跑得比 Python 快？**
    - 两者语言类型不同：c是**编译型**，运行前编译器会把源代码翻译成机器码，cpu可以直接理解并执行；python是**解释型**，运行时解释器需逐行读取并翻译成字节码
2. **为什么很多团队会选择 “C++ 写核心逻辑，Python 负责调度” 的混合模式？**
   - 这种混合架构结合了两种语言的优势，并规避了缺陷，如c++负责计算密集型任务，Python处理高层逻辑和调度，使得整个系统高效灵活
3. **解释型语言真的就不用编译吗？**
   - 解释型语言并非不用编译，而是不编译成机器码。如Python在执行时，解释器会将`.py`源代码编译成`.pyc`字节码文件，然后虚拟机读取这些字节码并继续解释执行
   > 纯粹的不做任何编译、直接解释源代码的语言基本已经不存在了。             
   ———DeepSeek

*****
### 4.访问链接
- https://github.com/yangchunyu-1/JoTang2025/blob/main/%234-yangchunyu/demo.i
- https://github.com/yangchunyu-1/JoTang2025/blob/main/%234-yangchunyu/demo.s
- https://github.com/yangchunyu-1/JoTang2025/blob/main/%234-yangchunyu/demo.o
- https://github.com/yangchunyu-1/JoTang2025/blob/main/%234-yangchunyu/demo.exe
- https://github.com/yangchunyu-1/JoTang2025/blob/main/%234-yangchunyu/makefile
  >（没有完全弄懂makefile，这个代码经过了AI的修改）

   
